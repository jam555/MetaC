
	
typedef struct _errorhooks
{
	retframe plainerr, parenerr, curlerr, sqarerr;
	
} _errorhooks;
static _errorhooks hooks;
int _errorhooks_swapdefaults( _errorhooks *alt )
{
	if( alt )
	{
		retframe swap;
		
		swap = hooks.plainerr;
		hooks.plainerr = alt->plainerr;
		alt->plainerr = swap;
		
		swap = hooks.parenerr;
		hooks.parenerr = alt->parenerr;
		alt->plainerr = swap;
		
		swap = hooks.curlerr;
		hooks.curlerr = alt->curlerr;
		alt->curlerr = swap;
		
		swap = hooks.sqarerr;
		hooks.sqarerr = alt->sqarerr;
		alt->sqarerr = swap;
		
		return( 1 );
	}
	
	return( -1 );
}




typedef struct _specials
{
	token_head th;
	
	tokhdptr_parr *breaks, *bads, *starts;
	token_head *start, *end;
	
	uintptr_t bookmark;
	
} _specials;
#define INIT__SPECIALS( tokhead,  brkparr, badparr, strtparr,  strtthead, endthead ) \
	(_specials){ (tokhead),  &(brkparr), &(badparr), &(strtparr),  &(strtthead), &(endthead),  0 }
retframe _exit( stackpair *stkp, void *v_ )
{
	???
	
	if( !_errorhooks_swapdefaults( (_errorhooks*)v_ ) )
	{
		???
	}
	
	???
}
	/* ( token* -- ( token* 0 ) | ( tokengroup* 1 ) | ( tokengroup* 2 ) ) */
	/* v_ must point to an _errorhooks instance, and that instance MUST be */
	/*  allocated on the stack. If it's statically allocated, then things */
	/*  will irrevocably break. */
	/* Actually, no, it CAN'T be on the stack because of how the runloop */
	/*  will call THIS function... */
retframe _entry( stackpair *stkp, void *v_ )
{
	static token_head
		parenplain = INIT_TOKENHEAD( TOKTYPE_OPPAR, 0,  0,  0, 0, 0 ), /* ( */
		parenup = INIT_TOKENHEAD( TOKTYPE_OPPARUP, 0,  0,  0, 0, 0 ), /* (^ */
		curlup = INIT_TOKENHEAD( TOKTYPE_OPCRLUP, 0,  0,  0, 0, 0 ), /* {^ */
		sqarup = INIT_TOKENHEAD( TOKTYPE_OPSQRUP, 0,  0,  0, 0, 0 ), /* [^ */
		
		plainparen = INIT_TOKENHEAD( TOKTYPE_SYM_PARENCLOSE, 0,  0,  0, 0, 0 ), /* ) */
		upparen = INIT_TOKENHEAD( TOKTYPE_SYM_PREPARCL, 0,  0,  0, 0, 0 ), /* ^) */
		upcurl = INIT_TOKENHEAD( TOKTYPE_SYM_PRECRLCL, 0,  0,  0, 0, 0 ), /* ^} */
		upsqar = INIT_TOKENHEAD( TOKTYPE_SYM_PRESQRCL, 0,  0,  0, 0, 0 ), /* ^] */
		
		comma = INIT_TOKENHEAD( TOKTYPE_SYM_COMMA, 0,  0,  0, 0, 0 ); /* , */
	
#define _entry_DEF_tokhdptr_parr( ... ) \
		LIB4_DEFINE_PASCALARRAY_LITERAL2( tokenheadptr_, token_head*, __VA_ARGS__ )
	static tokhdptr_parr
		nobreaks = _entry_DEF_tokhdptr_parr(  ),
		commabreaks = _entry_DEF_tokhdptr_parr( &comma ),
		
		plainbads = _entry_DEF_tokhdptr_parr( upparen, upcurl, upsqar ),
		parenbads = _entry_DEF_tokhdptr_parr( plainparen, upcurl, upsqar ),
		curlbads = _entry_DEF_tokhdptr_parr( plainparen, upparen, upsqar ),
		sqarbads = _entry_DEF_tokhdptr_parr( plainparen, upparen, upcurl ),
		
		starters = _entry_DEF_tokhdptr_parr( parenplain, parenup, curlup, sqarup );
	
	
	
	
	???
	
	
	
	
	
	
	
	static _specials
		plainspecs = INIT__SPECIALS( tokhead ???,  nobreaks, plainbads, starters,  parenplain, plainparen ),
		parenspecs = INIT__SPECIALS( tokhead ???,  commabreaks, parenbads, starters,  parenup, upparen ),
		curlspecs = INIT__SPECIALS( tokhead ???,  commabreaks, curlbads, starters,  curlup, upcurl ),
		sqarspecs = INIT__SPECIALS( tokhead ???,  commabreaks, sqarbads, starters,  sqarup, upsqar );
	
	
	static retframe_parr
			/* (
				token* bookmark --
					bookmark token* --
					... --
				( token* 0 ) | ( tokengroup* 1 ) | ( tokengroup* tokengroup* token* 2 )
			) */
		onset_ =
			(retframe_parr)
			{
				3, /* Number of retframes  */
				{
						/* ( token* bookmark -- bookmark token* ) */
					(retframe){ &swap2nd, (void*)0 },
						(retframe){ &just_run, (void*)0 },
					(retframe){ &_exit, (void*)0 }
				}
			},
		
			/* ( tokengroup* tokengroup* token* ( 2 ??? ) bookmark -- tokengroup* 2 bookmark ) */
		onerr_ =
			(retframe_parr)
			{
				???, /* Number of retframes  */
				{
					/* The file-static named "hooks" should hold */
					/*  all of the hooks that we need for this. */
					/*  SHOULD. Maybe review it to make certain */
					/*  that it actually does. */
					
					???
				}
			};
	
		/* Remember, the adjusted stuff will get handed directly to */
		/*  enqueue_returns(): it'll be dealt with before there's a */
		/*  chance of the value getting changed again. */
#fefine _entry_RETURN_ONSET( hookname, localname ) \
		onset_.body[ 1 ].data = (void*)&( hookname ); \
		onset_.body[ 2 ].data = v_; \
		return( (retframe){ &enqueue_returns, (void*)&localname } );
	
	retframe
		onset = { &enqueue_returns, (void*)&onset_ },
		
		plain_onerr = { &, (void*)0 },
		paren_onerr = { &, (void*)0 },
		curl_onerr = { &, (void*)0 },
		sqar_onerr = { &, (void*)0 },
		
		??? ;
	
	
		/* bookmark needs to be the name for a uintptr_t, localname will be the name for */
		/*  a retframe_parr that can be used with enqueue_returns(). onset_ptr and */
		/*  onjump_ptr need to be pointers to retframe instances: you should be able to */
		/*  figure out the purpose yourself. Several names will be constructed with */
		/*  prefix at the start, and upper-case text continuing afterwards. */
		/* Note that the user-provided onset and onjump retframes will have to contend */
		/*  with a uintptr_t on top of the data stack: THEY MUST NOT SCREW AROUND WITH */
		/*  THIS (other than to VERY CAREFULLY move stuff underneath it), lest the */
		/*  entire system break, IT MUST BE ON TOP OF THE STACK UPON BOTH onset{} AND */
		/*  onjump{}'s RETURNS. Seriously, here there be dragons. */
		/* Effectively: */
			/* (retframe){ &enqueue_returns, (void*)&localname } : */
			/*  (  -- uintptr_t-bookmark ) -> onset ->  ( uintptr_t-bookmark --  ) */
	LOCALIZE_SETJUMP( plainspecs.bookmark, plaincallable, plainspace,  &onset, &plain_onerr );
	LOCALIZE_SETJUMP( parenspecs.bookmark, parencallable, parenspace,  &onset, &paren_onerr );
	LOCALIZE_SETJUMP( curlspecs.bookmark, curlcallable, curlspace,  &onset, &curl_onerr );
	LOCALIZE_SETJUMP( sqarspecs.bookmark, sqarcallable, sqarspace,  &onset, &sqar_onerr );
	
	
	int scratch;
	STACKCHECK2( stkp, v_,  _entry );
	
	
	if( ( (*_errorhooks)v_ )->th.toktype != ??? )
	{
		???
	}
	if( !_errorhooks_swapdefaults( (_errorhooks*)v_ ) )
	{
		???
	}
	
	
	uintptr_t tok;
	STACKPEEK_UINT( &( stkp->data ), 0, tok,  _entry, scratch );
	token_head *th = (token_head*)tok;
	if( !th )
	{
		???
	}
	
	switch( th->toktype )
	{
		case TOKTYPE_OPPAR: /* ( */
			_entry_RETURN_ONSET( plainspecs, plaincallable );
			
		case TOKTYPE_OPPARUP: /* (^ */
			_entry_RETURN_ONSET( parenspecs, parencallable );
		case TOKTYPE_OPCRLUP: /* {^ */
			_entry_RETURN_ONSET( curlspecs, curlcallable );
		case TOKTYPE_OPSQRUP: /* [^ */
			_entry_RETURN_ONSET( sqarspecs, sqarcallable );
			
			
		default:
			???
	}
}


























/* This code is mostly complete. */
/*  Having said that, the longjump() stuff isn't yet used (it should be, as */
/*  a replacement for other exits in syntax-error cases), various errors */
/*  need to be filled in, the search function isn't receiving all of it's */
/*  arguments, and entry() needs to be reviewed to ensure those ??? markers */
/*  can be dropped. */
/* The "ending bracket case" in accumulate_argrecep() needs to properly */
/*  finalize the arg set- this should probably be done with a retframe_parr{} */
/*  pulled out of entry()... */
/* In fact, most or all of the retframe_parr{}s in entry() (and several of */
/*  the token{}s as well, if not even more things) should be pulled out into */
/*  the file scope instead of cluttering up entry(). */
/* errhandler in entry() probably needs to call exit(), or reproduce it's */
/*  behavior. */



int is_execable( token *tok,  generic_named **found )
{
	generic_named *found_ = (generic_named*)0;
	if( !found )
	{
		found = &found;
	}
	
		/* Some of the directives CAN'T be inlined, so we need to */
		/*  differentiate on that. */
	genname_parr *searchtable = ( was_freshline( (token_head*)tok ) ? freshline : inline );
	
	*found =  = bsearch1_gennamearr( searchbatch, tok );
	
	if( !( *found ) )
	{
		/* Just a token, simple exit. */
		
		return( 0 );
		
	} else if( ( *found )->reftype == GENNAMETYPE_RETFRAMEFUNC )
	{
		if( !( ( *found )->ref ) )
		{
				/* Error, no reference, fatal error! */
			TRESPASSPATH( is_execable, "Error! Null ( *found )->ref value!" );
			
			return( -2 );
		}
		
		return( 1 );
		
	} else {
		
		TRESPASSPATH( is_execable, "Error! Unknown ( *found )->reftype value: " );
			DECARG( ( ( *found )->reftype ) );
		
		return( -3 );
	}
	
	/* We should never reach here. */
}
retframe on_execable( stkp, v_ );

static uintptr_t callerinfo_typeid;
static divertthread_callerinfo escapeinfo = { (uintptr_t)&callerinfo_typeid, ??? };
#define VALUE_subordinateinfo \
	(divertthread_info){  ???, &escapeinfo }
static divertthread_info subordinateinfo = VALUE_subordinateinfo;

typedef struct specials
{
	token_head th;
	
	tokhdptr_parr *breaks, *bads, *starts;
	token_head *start, *end;
	
	divertthread_info *jumpinfo;
	
} specials;
#define INIT__SPECIALS( tokhead,  brkparr, badparr, strtparr,  strtthead, endthead ) \
	(specials){ (tokhead),  &(brkparr), &(badparr), &(strtparr),  &(strtthead), &(endthead),  &subordinateinfo }



retframe exit( stkp, v_ )
{
	int scratch;
	
	uintptr_t tok;
	
		/* Do we even have stkp and v_? */
	???
	
		/* Are we looking at a valid stack state? Let's see */
		/*  if our identifier is at the right spot on the stack. */
	scratch = peek_divertthread_callerinfo( &( stkp->data ),  sizeof( uintptr_t ),  (divertthread_callerinfo*)0, &tok );
	if( !scratch )
	{
		???
	}
	if( tmp != (uintptr_t)&callerinfo_typeid )
	{
		/* Massive error! Invalid stack! Not recoverable! */
		
		???
	}
	
	
		/* This is in the way, move it. */
	STACKPOP_UINT( &( stkp->data ), tok,  entry, scratch );
		
			/* First things first, restore the divertthread info! */
		scratch = pop_divertthread_callerinfo( &( stkp->data ),  &escapeinfo );
		if( !scratch )
		{
			???
		}
		scratch = pop_divertthread_info( &( stkp->data ),  &subordinateinfo );
		if( !scratch )
		{
			???
		}
		
		/* And now move the "token" back onto the stack. */
	STACKPUSH_UINT( &( stkp->data ), tok,  entry, scratch );
	
	
		/* TOKEN_EQUALS_SIMPLECOMP_BODY( headptr_a, headptr_b,  on_badargs,  badtype_case, badlen_case, badchar_case, match_case ) */
	if( ( (token_head*)tok )->toktype != ( (specials*)v_ )-> ??? ->toktype )
	{
		/* Error: bracket mismatch! */
	}
	
	RETFRAMEFUNC( entry, scratch );
}
		/* Handles commas. */
	retframe queue_argrecep( stkp, v_ );
		/* Gathers tokens to fill out the current argument, dispatching */
		/*  otherwise if appropriate for the token. */
		/* v_ must be non-null. */
		/* ( tokengroup* token* -- ... ) */
	retframe accumulate_argrecep( stkp, v_ )
	{
#define accumulate_argrecep_SIMPLYBREAK( ... ) /* Success. */ break;
#define accumulate_argrecep_ISINFUNC_NULLARG( arga, argb ) ???
#define accumulate_argrecep_ISINFUNC_NULLELEM( arga, argb, offset ) ???
		
		int scratch;
		
		???
		
		specials *spec = (specials*)v_;
		uintptr_t tok;
		size_t matchloc;
		
		STACKPEEK_UINT( &( stkp->data ), 0, tok,  accumulate_argrecep, scratch );
		
			/* Have we found an illegal token? */
#define accumulate_argrecep_ONILLEGAL( arga, argb, offset ) ???
		ISIN_TOKHDPTR_PARR_RUN(
			tok, spec->bads, &matchloc,
			
			accumulate_argrecep_ISINFUNC_NULLARG, accumulate_argrecep_ISINFUNC_NULLELEM,
			accumulate_argrecep_ONILLEGAL,
			accumulate_argrecep_SIMPLYBREAK,
			
			&errs, accumulate_argrecep, scratch, endfunc ???
		);
		
			/* Have we found an argument seperator? */
#define accumulate_argrecep_ONSEPARATOR( arga, argb, offset ) return( (retframe){ &queue_argrecep, v_ } );
		ISIN_TOKHDPTR_PARR_RUN(
			tok, spec->bads, &matchloc,
			
			accumulate_argrecep_ISINFUNC_NULLARG, accumulate_argrecep_ISINFUNC_NULLELEM,
			accumulate_argrecep_ONSEPARATOR,
			accumulate_argrecep_SIMPLYBREAK,
			
			&errs, accumulate_argrecep, scratch, endfunc ???
		);
		
			/* Have we found a new bracket entry? */
#define accumulate_argrecep_ONBRACKETSTARTER( arga, argb, offset ) ???
		ISIN_TOKHDPTR_PARR_RUN(
			tok, spec->bads, &matchloc,
			
			accumulate_argrecep_ISINFUNC_NULLARG, accumulate_argrecep_ISINFUNC_NULLELEM,
			accumulate_argrecep_ONBRACKETSTARTER,
			accumulate_argrecep_SIMPLYBREAK,
			
			&errs, accumulate_argrecep, scratch, endfunc ???
		);
		
			/* Have we found the ending bracket? */
#define accumulate_argrecep_BADARGS( err ) /* One or both arguments were provided as null. */ ???
#define accumulate_argrecep_ONEND( thead_a, thead_)b, int_res ) \
	/* We encountered the (or a?) ending token. The bracket pair is done. */ \
	??? /* We need to discard the ending token, then compress the args... this doesn't do that yet. */ \
	RETFRAMEFUNC( stkp,  swapshuffle2data );
		TOKEN_EQUALS_SIMPLECOMP_BODY(
			tok, spec->end,
			
			accumulate_argrecep_BADARGS,
			
			accumulate_argrecep_SIMPLYBREAK, accumulate_argrecep_SIMPLYBREAK, accumulate_argrecep_SIMPLYBREAK,
			accumulate_argrecep_ONEND
		);
		
			/* The token wasn't one of the types that causes specials-specific */
			/*  behavior, so let's search the executable table. */
		retframe_parr *retcalls = (retframe_parr*)0;
		static retframe dynamic_recursor;
		dynamic_recursor = (retframe){ &accumulate_argrecep, v_ };
			/* Search for a macro or directive entrance. */
		scratch = is_execable( (token*)tok,  generic_named **found );
		switch( scratch )
		{
			case 0:
				/* Not exec-capable. We just use the token as a... token. */
				
				static retframe_parr
					not_execable_inner =
						(retframe_parr)
						{
							2, /* Number of retframes  */
							{
									/* ( tokengroup* token_head* -- tokengroup* ) */
								(retframe){ &vm_pushto_tokengroup, (void*)0 },
									/* ( -- token* ) */
								(retframe){ &token_queue_fetch, (void*)0 }
								
									/* ( tokengroup* token* -- ... ) */
								/* We will mystically, magically, proceed into */
								/*  accumulate_argrecep(), but it's probably best */
								/*  not to think about how too horribly much. */
							}
						},
					not_execable_outer =
						(retframe_parr)
						{
							3, /* Number of retframes  */
							{
								(retframe){ &vm_pushretframe, (void*)&dynamic_recursor }
									/* ( retframe -- ret: retframe ) */
								(retframe){ &swap_retframe2ret, (void*)0 },
								(retframe){ &enqueue_returns, (void*)&not_execable_inner }
							}
						};
				
				retcalls = &not_execable_outer;
				
				break;
			case 1:
				/* Exec-capable. Dispatch to "retframe on_execable( stkp, v_ )". */
				
				static retframe_parr
					execable =
						(retframe_parr)
						{
							4, /* Number of retframes  */
							{
									/* ( token* -- token* ) */
								(retframe){ &on_execable, (void*)0 },
								(retframe){ &vm_pushretframe, (void*)&dynamic_recursor }
									/* ( retframe -- ret: retframe ) */
								(retframe){ &swap_retframe2ret, (void*)0 },
								(retframe){ &enqueue_returns, (void*)&not_execable_inner }
							}
						};
				
				retcalls = &execable;
				break;
			case -3: /* Unrecognized generic_named->reftype */
			case -2: /* Uninitialized generic_named->ref */
			default: /* Unknown error. */
				
				STDMSG_FAILEDINTFUNC_WRAPPER( &errs, "is_execable()", accumulate_argrecep, scratch );
					STDMSG_NOTELINE_WRAPPER( &errs ); STDMSG_DATAPTRARG_WRAPPER( &errs, (token*)tok );
					STDMSG_NOTESPACE_WRAPPER( &errs ); STDMSG_DATAPTRARG_WRAPPER( &errs, generic_named **found );
				
				stack_ENDRETFRAME();
		}
		return( (retframe){ &enqueue_returns, (void*)retcalls } );
	}
		/* Handles commas. */
		/* Condense the current tokengroup{}, move into the parent */
		/*  tokengroup{}, and push a new tokengroup{} onto the stack. */
		/* v_ must be non-null. */
		/* ( tokengroup* tokengroup* token* -- ... ) */
	retframe queue_argrecep( stkp, v_ )
	{
		
		int scratch;
		
		???
		
		specials *spec = (specials*)v_;
		uintptr_t tok;
		size_t matchloc;
		
		STACKPEEK_UINT( &( stkp->data ), 0, tok,  queue_argrecep, scratch );
		
			/* Confirm we have an argument seperator. */
#define queue_argrecep_SIMPLYBREAK( ... ) /* Success. */ break;
			/* These three are all errors. */
#define queue_argrecep_ISINFUNC_NULLARG( arga, argb ) ???
#define queue_argrecep_ISINFUNC_NULLELEM( arga, argb, offset ) ???
#define queue_argrecep_NOSEPARATOR( arga, argb ) ???
		ISIN_TOKHDPTR_PARR_RUN(
			tok, spec->breaks, &matchloc,
			
			queue_argrecep_ISINFUNC_NULLARG, queue_argrecep_ISINFUNC_NULLELEM,
			queue_argrecep_SIMPLYBREAK,
			queue_argrecep_NOSEPARATOR,
			
			&errs, accumulate_argrecep, scratch, endfunc ???
		);
		
		static retframe_parr
			seq =
				(retframe_parr)
				{
					8, /* Number of retframes  */
					{
							/* We actually don't care about the seperator anymore. */
						(retframe){ &invoke_dealloctoken, (void*)0 },
						
						/* Shove the newest argument group into the deeper tokengroup{}. */
							/* ( tokengroup* tokengroup* -- tokengroup* ) */
						(retframe){ &vm_pushto_tokengroup, (void*)0 },
						
							/* ... and then replace it. */
						(retframe){ &vm_buildempty_tokengroup, (void*)0 },
								/* v_ = &uintptr_t; uintptr_t = data; (  -- data ) */
							(retframe){ &vm_pushdata, (void*) & ??? },
								/* ( tokengroup* token_head* -- tokengroup* token_head* ) */
							(retframe){ &vm_setsubtype_tokengroup, (void*)0 },
							(retframe){ &invoke_dealloctoken, (void*)0 },
						
						/* Recurse back to accumulate_argrecep() */
							/* ( -- token* ) */
						(retframe){ &token_queue_fetch, (void*)0 },
							/* The void* for accumulate_argrecep gets dynamically patched */
							/*  below! */
						(retframe){ &accumulate_argrecep, (void*)0 }
					}
				};
		seq.body[ 7 ].data = v_;
		return( (retframe){ &enqueue_returns, (void*)&seq } );
	}
		/* ( token* -- ( token* 0 ) | ( tokengroup* 1 ) | ( tokengroup* 2 ) ) */
reframe entry( stkp, v_ )
{
	??? /* TODO: upgrade all of these to full tokens. */
	static token
		parenplain = INIT_TOKEN_GENERIC( TOKTYPE_OPPAR, "(" ), /* ( */
		parenup = INIT_TOKEN_GENERIC( TOKTYPE_OPPARUP, "(^" ), /* (^ */
		curlup = INIT_TOKEN_GENERIC( TOKTYPE_OPCRLUP, "{^" ), /* {^ */
		sqarup = INIT_TOKEN_GENERIC( TOKTYPE_OPSQRUP, "[^" ), /* [^ */
		
		plainparen = INIT_TOKEN_GENERIC( TOKTYPE_SYM_PARENCLOSE, ")" ), /* ) */
		upparen = INIT_TOKEN_GENERIC( TOKTYPE_SYM_PREPARCL, "^)" ), /* ^) */
		upcurl = INIT_TOKEN_GENERIC( TOKTYPE_SYM_PRECRLCL, "^}" ), /* ^} */
		upsqar = INIT_TOKEN_GENERIC( TOKTYPE_SYM_PRESQRCL, "^]" ), /* ^] */
		
		comma = INIT_TOKEN_GENERIC( TOKTYPE_SYM_COMMA, "," ), /* , */
		
			/* These three are used to configure tokengroup{}s. */
		argset = INIT_TOKEN_GENERIC( TOKTYPE_TOKENGROUP_ARGSET, "??? (a set of arguments)" ),
		argcontainer = INIT_TOKEN_GENERIC( TOKTYPE_TOKENGROUP_ARG, "??? (a single argument)" ),
		arggeneric = INIT_TOKEN_GENERIC( TOKTYPE_GENERICGROUP, "??? (a filler toktype for single arguments)" ),
		
			/* This one is used to mark errors. */
		errored = INIT_TOKEN_GENERIC( TOKTYPE_TOKENGROUP_ERROREDSET, "??? (a tokengroup that errored mid-build)" );
	
#define entry_DEF_tokhdptr_parr( ... ) \
		LIB4_DEFINE_PASCALARRAY_LITERAL2( tokenheadptr_, token_head*, __VA_ARGS__ )
	static tokhdptr_parr
		nobreaks = entry_DEF_tokhdptr_parr(  ),
		commabreaks = entry_DEF_tokhdptr_parr( &( comma.header ) ),
		
		plainbads = entry_DEF_tokhdptr_parr( ( upparen.header ), ( upcurl.header ), ( upsqar.header ) ),
		parenbads = entry_DEF_tokhdptr_parr( ( plainparen.header ), ( upcurl.header ), ( upsqar.header ) ),
		curlbads = entry_DEF_tokhdptr_parr( ( plainparen.header ), ( upparen.header ), ( upsqar.header ) ),
		sqarbads = entry_DEF_tokhdptr_parr( ( plainparen.header ), ( upparen.header ), ( upcurl.header ) ),
		
		starters = entry_DEF_tokhdptr_parr( ( parenplain.header ), ( parenup.header ), ( curlup.header ), ( sqarup.header ) );
	
	static specials
		plainspecs =
			INIT__SPECIALS(
				INIT_TOKENHEAD( TOKTYPE_CONTEXTSPECIALS, 0,  0,  0, 0, 0 ),
				nobreaks,
				plainbads,
				starters,
				
				( parenplain.header ),
				( plainparen.header )
			),
		parenspecs =
			INIT__SPECIALS(
				INIT_TOKENHEAD( TOKTYPE_CONTEXTSPECIALS, 0,  0,  0, 0, 0 ),
				commabreaks,
				parenbads,
				starters,
				
				( parenup.header ),
				( upparen.header )
			),
		curlspecs =
			INIT__SPECIALS(
				INIT_TOKENHEAD( TOKTYPE_CONTEXTSPECIALS, 0,  0,  0, 0, 0 ),
				commabreaks,
				curlbads,
				starters,
				
				( curlup.header ),
				( upcurl.header )
			),
		sqarspecs =
			INIT__SPECIALS(
				INIT_TOKENHEAD( TOKTYPE_CONTEXTSPECIALS, 0,  0,  0, 0, 0 ),
				commabreaks,
				sqarbads,
				starters,
				
				( sqarup.header ),
				( upsqar.header )
			);
	
		/* This provides common behavior for the *script retframe_parr{}s. */
	static retframe_parr
			/* Push two tokengroup{}s onto the stack for use as things go along. */
		preprep_arglist =
			(retframe_parr)
			{
				??? , /* Number of retframes  */
				{
					??? /* WARNING: if you make any changes, then adjust the */
						/*  "subordinate function" sigs, and thus details! */
					
					(retframe){ &vm_buildempty_tokengroup, (void*)0 },
							/* v_ = &uintptr_t; uintptr_t = data; (  -- data ) */
						(retframe){ &vm_pushdata, (void*) &argset },
								/* ( dest-token_head* src-token_head* -- dest-token_head* src-token_head* ) */
							(retframe){ &vm_tokenhead_settoktype, (void*)0 },
								/* The token* from vm_pushdata() will be a static */
								/*  allocation, so deallocation would likely segfault... */
						(retframe){ &drop, (void*)0 },
							/* ( token* tokengroup* -- tokengroup* token* ) */
						(retframe){ &swap2nd, (void*)0 },
								/* ( tokengroup* token_head* -- tokengroup* token_head* ) */
							(retframe){ &vm_setsubtype_tokengroup, (void*)0 },
						(retframe){ &invoke_dealloctoken, (void*)0 },
					(retframe){ &vm_buildempty_tokengroup, (void*)0 },
						(retframe){ &vm_pushdata, (void*) &argcontainer },
							(retframe){ &vm_tokenhead_settoktype, (void*)0 },
						(retframe){ &drop, (void*)0 },
						(retframe){ &vm_pushdata, (void*) &arggeneric },
							(retframe){ &vm_setsubtype_tokengroup, (void*)0 },
						(retframe){ &drop, (void*)0 },
					
					???
				}
			};
	
	
	static retframe_parr
		plainscript =
			(retframe_parr)
			{
				??? , /* Number of retframes  */
				{
					???
					
						/* (  -- tokengroup* tokengroup* ) */
					(retframe){ &enqueue_returns, (void*)&preprep_arglist },
					
					???
					
						/* ( -- token* ) */
					(retframe){ &token_queue_fetch, (void*)0 },
						/* ( tokengroup* token* -- ... ) */
					(retframe){ &accumulate_argrecep, (void*)&plainspecs },
					
					???
				}
			},
		parenscript =
			(retframe_parr)
			{
				??? , /* Number of retframes  */
				{
					???
					
						/* (  -- tokengroup* tokengroup* ) */
					(retframe){ &enqueue_returns, (void*)&preprep_arglist },
					
					???
					
						/* ( -- token* ) */
					(retframe){ &token_queue_fetch, (void*)0 },
						/* ( tokengroup* token* -- ... ) */
					(retframe){ &accumulate_argrecep, (void*)&parenspecs },
					
					???
				}
			},
		curlscript =
			(retframe_parr)
			{
				??? , /* Number of retframes  */
				{
					???
					
						/* (  -- tokengroup* tokengroup* ) */
					(retframe){ &enqueue_returns, (void*)&preprep_arglist },
					
					???
					
						/* ( -- token* ) */
					(retframe){ &token_queue_fetch, (void*)0 },
						/* ( tokengroup* token* -- ... ) */
					(retframe){ &accumulate_argrecep, (void*)&curlspecs },
					
					???
				}
			},
		sqarscripts =
			(retframe_parr)
			{
				??? , /* Number of retframes  */
				{
					???
					
						/* (  -- tokengroup* tokengroup* ) */
					(retframe){ &enqueue_returns, (void*)&preprep_arglist },
					
					???
					
						/* ( -- token* ) */
					(retframe){ &token_queue_fetch, (void*)0 },
						/* ( tokengroup* token* -- ... ) */
					(retframe){ &accumulate_argrecep, (void*)&sqarspecs },
					
					???
				}
			},
		
			/* ( tokengroup*args tokengroup*arg token* bookmark -- tokengroup*args bookmark ) */
		errhandler =
			(retframe_parr)
			{
				9, /* Number of retframes  */
				{
						/* ( tokengroup*args tokengroup*arg token* bookmark -- ... ) */
					(retframe){ &swapdata2shuffle, void*)0 },
					(retframe){ &swapdata2shuffle, void*)0 },
						/* ( ... -- data: tokengroup*args tokengroup*arg   shuffle: bookmark token* ) */
					
						/* ( tokengroup*args tokengroup*arg -- tokengroup*args ) */
					(retframe){ &vm_pushto_tokengroup, (void*)0 },
					
					
						/*
							(
									data: tokengroup*args   shuffle: bookmark token*
								--
									data: tokengroup*args token*   shuffle: bookmark
							)
						*/
					(retframe){ &swapshuffle2data, void*)0 },
						/* ( tokengroup*args token* -- tokengroup*args ) */
					(retframe){ &vm_pushto_tokengroup, (void*)0 },
					
					/* Remark tokengroup*args as erroneous. */
						/* v_ = &uintptr_t; uintptr_t = data; (  -- data ) */
					(retframe){ &vm_pushdata, (void*) &errored },
							/* ( dest-token_head* src-token_head* -- dest-token_head* src-token_head* ) */
						(retframe){ &vm_tokenhead_settoktype, (void*)0 },
							/* The token* from vm_pushdata() will be a static */
							/*  allocation, so deallocation would likely segfault... */
					(retframe){ &drop, (void*)0 },
					
						/* Prepare to reenter the setjump()/longjump() logic... */
					(retframe){ &swapshuffle2data, void*)0 }
						/* ( ... -- tokengroup*args bookmark ) */
				}
			};
	
	
	
	
	
	
	???
	
	
	
	
	
	int scratch;
	
	retframe ret;
	
	uintptr_t tok;
	STACKPOP_UINT( &( stkp->data ), tok,  entry, scratch );
	
		/* Save the old divertthread info- we'll be needing it if this was nested. */
	scratch = push_divertthread_info( &( stkp->data ), subordinateinfo );
	if( !scratch )
	{
		???
	}
		/* Yes, this MUST come last, because it'll ensure that *_callerinfo type id */
		/*  is on TOP of the stack. */
	scratch = push_divertthread_callerinfo( &( stkp->data ), escapeinfo );
	if( !scratch )
	{
		???
	}
	
		/* Restored! And it's on top of the stuff that we won't need till exit! */
	STACKPUSH_UINT( &( stkp->data ), tok,  entry, scratch );
	
	
	
		/* Reset the divertthread_info to a nice, safe default. */
	subordinateinfo = VALUE_subordinateinfo;
	
	static retframe_parr
		seq =
			(retframe_parr)
			{
				2, /* Number of retframes  */
				{
						/* v_ must be a pointer to a divertthread_info{}. The */
						/*  values of the elements in the provided instance */
						/*  will be swapped with "foreign" values during the */
						/*  longevity of the provided setfunc and jumpfunc */
						/*  framefunc{}s, DON'T SCREW WITH THOSE VALUES. The */
						/*  CONTENTS of ->recepdata won't be touched, with */
						/*  the exception of ->earlyexit, which (IF */
						/*  ->recepdata is non-null) will be initialized so */
						/*  that user code can actually use it. */
						/* Named in reference Unix's fork() function, but it */
						/*  just diverts execution of the current thread */
						/*  while providing a special exit mechanism to */
						/*  preemptively get back out of that diversion. */
						/* subordinateinfo is an instance of */
						/*  divertthread_info{}. I don't remember why I named */
						/*  it "subordinate". */
						/* ( uintptr_t -- ??? ) : The uintptr_t is an arg to */
						/*  ->setfunc, but divertthread() assumes it's */
						/*  presence. */
					(retframe){ &divertthread, (void*)&subordinateinfo },
					
						/* ( tokengroup* token* -- ... ) */
					(retframe){ &exit, (void*)0 }
				}
			};
#define entry_PATCHSEQ( exit_v_ ) seq.body[ 1 ].data = (void*)( exit_v_ );
	scratch = simplify_toktype( (token_head*)tok,  &tok );
	if( !scratch )
	{
		???
	}
	switch( tok )
	{
		case TOKTYPE_OPPAR:
				/* Both of these functions MUST comply with the following function */
				/*  signature: */
					/* ( ???1 bookmark -- ???2 bookmark ) */
				/*  What is under "bookmark" DOES NOT matter, but "bookmark" WILL */
				/*  BE on top upon entry, and MUST BE on top AND UNALTERED upon */
				/*  exit, lest the entire system break. This is NOT a small thing, */
				/*  it can completely screw up the stack. */
			subordinateinfo.setfunc = (retframe){ &enqueue_returns, (void*)&plainscript };
			subordinateinfo.jumpfunc = (retframe){ &enqueue_returns, (void*)&errhandler };
			entry_PATCHSEQ( &plainspecs );
			break;
		case TOKTYPE_OPPARUP:
			subordinateinfo.setfunc = (retframe){ &enqueue_returns, (void*)&parenscript };
			subordinateinfo.jumpfunc = (retframe){ &enqueue_returns, (void*)&errhandler };
			entry_PATCHSEQ( &parenspecs );
			break;
		case TOKTYPE_OPCRLUP:
			subordinateinfo.setfunc = (retframe){ &enqueue_returns, (void*)&curlscript };
			subordinateinfo.jumpfunc = (retframe){ &enqueue_returns, (void*)&errhandler };
			entry_PATCHSEQ( &curlspecs );
			break;
		case TOKTYPE_OPSQRUP:
			subordinateinfo.setfunc = (retframe){ &enqueue_returns, (void*)&sqarscripts };
			subordinateinfo.jumpfunc = (retframe){ &enqueue_returns, (void*)&errhandler };
			entry_PATCHSEQ( &sqarspecs );
			break;
		default:
			??? /* Throw error: this should never have happened. */
	}
	return( (retframe){ &enqueue_returns, (void*)&seq } );
}
uintptr_t callerinfo_typeid = &callerinfo_typeid;

	/* Note: does not necessarily return the SAME token pointer. In fact, */
	/*  generally SHOULDN'T. */
	/* ( token* -- token* ) */
retframe on_execable( stkp, v_ )
{
	int scratch;
	
	???
	
	uintptr_t tok;
	STACKPEEK_UINT( &( stkp->data ), tok,  on_execable, scratch );
	
	generic_named *found;
	scratch = is_execable( (token*)tok,  &found );
	switch( scratch )
	{
		case 1:
			/* Exec-capable. */
			break;
		case 0:
			/* Not exec-capable: should never have gotten here. */
		case -2:
			/* generic_named->ref not initialized: also should never have gotten here. */
		case -3:
			/* generic_named->reftype unknown: still should never have gotten here. */
		default:
			/* Unknown error. */
			
			???
	}
	
	if( found->reftype != GENNAMETYPE_RETFRAMEFUNC )
	{
		/* Error! */
		
		???
	}
	if( !( found->ref ) )
	{
			/* Error, no reference, fatal error! */
		TRESPASSPATH( is_execable, "Error! Null ( *found )->ref value!" );
		
		???
	}
	
	return( *( (retframe*)( found->ref ) ) );
}





	
		/* Provides a way to temporarily store tokens that WILL be going onto */
		/*  the token's "unget" stack, for those cases when you need to reverse */
		/*  the order that they'll be pulled back off. */
	size_t token_queue_shuffleused();
	int token_queue_shufflepop( token **tok );
	int token_queue_shufflepush( token *tok );





















retframe bracketgather_invalidcall( stackpair *stkp, void *v_ )
{
	/* This should never be entered, it exists to alert when */
	/*  something fails to get set correctly. */
	
	???
}
	/* ( token* char_parr* -- ) */
retframe bracketgather_badtoken( stackpair *stkp, void *v_ )
{
	/* This should never be entered, it exists to alert when */
	/*  something fails to get set correctly. */
	
	???
}
retframe bracketgather_exit( stackpair *stkp, void *v_ )
{
	???
}
		/* ( tokengroup* tokengroup* token* char_parr* -- ??? ) */
	retframe bracketgather_loop_search( stackpair *stkp, void *v_ )
	{
		STACKCHECK2( stkp, v_,  bracketgather_loop );

		context_specials ctx = (context_specials*)v_;

		uintptr_t parr, tok;
		STACKPOP_UINT( &( stkp->data ), parr,  bracketgather_loop, scratch );
		STACKPEEK_UINT( &( stkp->data ), 0, tok,  bracketgather_loop, scratch );

			??? /* Does this belong here? Aren't we searching for macros? */
		genname_parr *searchbatch = ( was_freshline( (token_head*)tok ) ? freshline : inline );

			/* genericnamed* bsearch1_gennamearr( genname_parr *parr, token *tok ); */
		genericnamed *found_entry = bsearch1_gennamearr( searchbatch, (char_parr*)parr );
			/* We no longer need the pascal array, so time to delete it. */
		lib4_result res = char_pascalarray_destroy( (char_parr*)parr );
	#define bracketgather_loop_search_ERRREPORT( err ) \
			???; /* Do some reporting. */ \
			stack_ENDRETFRAME();
		LIB4_RESULT_BODYMATCH( res, LIB4_NULL_MACRO, bracketgather_loop_search_ERRREPORT );

		if( !found_entry )
		{
			/* It's just a token, so we'll push it. */

			static retframe_parr justtok =
				(retframe_parr)
				{
					3, /* Number of retframes  */
					{
							/* ( tokengroup* token* -- tokengroup* ) */
						(retframe){ &vm_pushto_tokengroup, (void*)0 },
						(retframe){ &token_queue_fetch, (void*)0 },
						(retframe){ &bracketgather_loop, (void*)0 }
					}
				};
				justtok.body[ 2 ].data = v_;
			return( (retframe){ &enqueue_returns, &justtok } );

		} else if( found_entry->reftype == GENNAMETYPE_RETFRAMEFUNC )
		{
			if( !( found_entry->ref ) )
			{
				BADNULL( bracketgather_loop, ptr );
				stack_ENDRETFRAME();
			}

			static retframe_parr activematch =
				(retframe_parr)
				{
					4, /* Number of retframes  */
					{
						(retframe){ &token_queue_fetch, (void*)0 },
							/* This is meant to be overwritten with the retframe at *( ->ref ). */
							/* ( tokengroup* token* token* -- tokengroup* ) */
						(retframe){ &bracketgather_invalidcall, (void*)0 },
						(retframe){ &token_queue_fetch, (void*)0 },
						(retframe){ &bracketgather_loop, (void*)0 }
					}
				};
					/* Patch in the reference that was found. */
				activematch.body[ 1 ].handler = ( (retframe*)( found_entry->ref ) )->handler;
				activematch.body[ 1 ].data = ( (retframe*)( found_entry->ref ) )->data;
				activematch.body[ 3 ].data = v_;
			return( (retframe){ &enqueue_returns, &activematch } );

		} else {

			TRESPASSPATH( bracketgather_loop, "Error! Unknown found_entry->reftype value: " );
				DECARG( ( found_entry->reftype ) );
			stack_ENDRETFRAME();
		}

		??? /* We should never reach here. */
	}
		/* ( tokengroup* tokengroup* token* -- ??? ) */
	retframe bracketgather_loop( stackpair *stkp, void *v_ )
	{
		STACKCHECK2( stkp, v_,  bracketgather_loop );

		context_specials ctx = (context_specials*)v_;

		uintptr_t tok, arggrp;
		STACKPEEK_UINT( &( stkp->data ), 0, tok,  bracketgather_loop, scratch );

		lib4_intresult res = not_contextspecials( (token_head*)tok, ctx );

	#define bracketgather_loop_ERRREPORT( err ) \
			???; /* Do some reporting. */ \
			stack_ENDRETFRAME();
		int a;
		LIB4_INTRESULT_BODYMATCH( res, LIB4_OP_SETa, bracketgather_loop_ERRREPORT );

		switch( a )
		{
			case -1:
				/* Ending token encountered. */

				static const retframe_parr ending =
					(retframe_parr)
					{
						2, /* Number of retframes  */
						{
									/* ( token_head* --  ) */
							(retframe){ &invoke_dealloctoken, (void*)0 },
								/* ( tokengroup* tokengroup* -- tokengroup* ) */
							(retframe){ &vm_pushto_tokengroup, (void*)0 }
						}
					};
				return( (retframe){ &enqueue_returns, &ending } );

			case 0:
				/* Break character (e.g. comma) encountered. */

				static retframe_parr comma =
					(retframe_parr)
					{
						5, /* Number of retframes  */
						{
									/* ( token_head* --  ) */
							(retframe){ &invoke_dealloctoken, (void*)0 },
								/* ( tokengroup* tokengroup* -- tokengroup* ) */
							(retframe){ &vm_pushto_tokengroup, (void*)0 },
							(retframe){ &vm_buildempty_tokengroup, (void*)0 },
							(retframe){ &token_queue_fetch, (void*)0 },
							(retframe){ &bracketgather_loop, (void*)0 }
						}
					};
					comma.body[ 4 ].data = v_;
				return( (retframe){ &enqueue_returns, &comma } );

			case 1:
				/* Other character encountered: needs additional decoding. */

				static const retframe badtok = (retframe){ bracketgather_badtoken&, (void*)0 };
				static retframe_parr other =
					(retframe_parr)
					{
						2, /* Number of retframes  */
						{
								/* ( token* -- token* char_parr* ) */
								/* v_ must point to a retframe{} to handle "unrecognized token type" errors. */
							(retframe){ &token2char_parr, (void*)( &badtok ) },
							(retframe){ &bracketgather_loop_search, (void*)0 }	
						}
					};
					comma.body[ 1 ].data = v_;
				return( (retframe){ &enqueue_returns, &other } );

			default:
				??? /* Erroneous result, report and fail. */
		}
	}
		/* ( tokengroup* token* -- ... ) */
	retframe bracketgather_check( stackpair *stkp, void *v_ )
	{
		???
			/* I think this might force an IMMEDIATE exit of the bracketgather */
			/*  subsystem- if so, then behavior needs to become more nuanced. */

		STACKCHECK2( stkp, v_,  bracketgather_check );

		context_specials ctx = (context_specials*)v_;

		int scratch;
		uintptr_t tok, tmp;
		FETCH_SIMPLETYPE( *( ctx->start ), tok,  bracketgather_check, scratch );

		STACKPEEK_UINT( &( stkp->data ), sizeof( uintptr_t ), tmp,  bracketgather_check, scratch );
	#define bracketgather_check_ONYES( ... ) \
			tokengroup *dest = build_tokengroup( 0 ); \
			STACKPUSH_UINT( &( stkp->data ), (uintptr_t)dest,  bracketgather_check, scratch ); \
			static retframe_parr seq = \
				(retframe_parr){ \
					5, /* Number of retframes  */ { \
						(retframe){ &swap2nd, (void*)0 }, \
								/* ( tokengroup* token_head* -- tokengroup* token_head* ) */ \
						(retframe){ &vm_setsubtype_tokengroup, (void*)0 }, \
						(retframe){ &invoke_dealloctoken, (void*)0 }, \
						(retframe){ &token_queue_fetch, (void*)0 }, \
						(retframe){ &bracketgather_loop, (void*)0 } } }; \
					/* And this is why seq{} isn't a const: we need to patch it at runtime. */ \
				seq.body[ 4 ].data = v_; \
			return( (retframe){ &enqueue_returns, &seq } );
	#define bracketgather_check_ONNO( ... ) \
			??? ; \
			stack_ENDRETFRAME();
		CHECK_SIMPLETYPE(
			*( (token_head*)tmp ), tok, bracketgather_check_ONYES, bracketgather_check_ONNO,
			bracketgather_check, scratch
		);
	}
	/* ( token_head* -- ??? ) */
retframe bracketgather_enter( stackpair *stkp, void *v_ )
{
	int scratch;
	
	STACKCHECK2( stkp, v_,  bracketgather_enter );
	
	if( ( (token_head*)v_ )->toktype != TOKTYPE_CONTEXTSPECIALS )
	{
		/* Error, bad type! */
		???
	}
	
	tokengroup *dest = build_tokengroup( 0 );
	if( !dest )
	{
		???;
	}
	STACKPUSH_UINT( &( stkp->data ), (uintptr_t)dest,  bracketgather_enter, scratch );
	
	static retframe_parr seq =
		(retframe_parr)
		{
			6, /* Number of retframes  */
			{
				(retframe){ &swap2nd, (void*)0 },
					/* ( tokengroup* token_head* -- tokengroup* token_head* ) */
				(retframe){ &vm_setsubtype_tokengroup, (void*)0 },
				(retframe){ &invoke_dealloctoken, (void*)0 },
				
				(retframe){ &token_queue_fetch, (void*)0 },
				(retframe){ &bracketgather_check, (void*)0 },
				(retframe){ &bracketgather_exit, (void*)0 }
			}
		};
		seq.body[ 4 ].data = v_;
		seq.body[ 5 ].data = v_;
	return( (retframe){ &enqueue_returns, &seq } );
}
