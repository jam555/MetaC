
	
typedef struct _errorhooks
{
	retframe plainerr, parenerr, curlerr, sqarerr;
	
} _errorhooks;
static _errorhooks hooks;
int _errorhooks_swapdefaults( _errorhooks *alt )
{
	if( alt )
	{
		retframe swap;
		
		swap = hooks.plainerr;
		hooks.plainerr = alt->plainerr;
		alt->plainerr = swap;
		
		swap = hooks.parenerr;
		hooks.parenerr = alt->parenerr;
		alt->plainerr = swap;
		
		swap = hooks.curlerr;
		hooks.curlerr = alt->curlerr;
		alt->curlerr = swap;
		
		swap = hooks.sqarerr;
		hooks.sqarerr = alt->sqarerr;
		alt->sqarerr = swap;
		
		return( 1 );
	}
	
	return( -1 );
}




typedef struct _specials
{
	token_head th;
	
	tokhdptr_parr *breaks, *bads, *starts;
	token_head *start, *end;
	
	uintptr_t bookmark;
	
} _specials;
#define INIT__SPECIALS( tokhead,  brkparr, badparr, strtparr,  strtthead, endthead ) \
	(_specials){ (tokhead),  &(brkparr), &(badparr), &(strtparr),  &(strtthead), &(endthead),  0 }
retframe _exit( stackpair *stkp, void *v_ )
{
	???
	
	if( !_errorhooks_swapdefaults( (_errorhooks*)v_ ) )
	{
		???
	}
	
	???
}
	/* ( token* -- ( token* 0 ) | ( tokengroup* 1 ) | ( tokengroup* 2 ) ) */
	/* v_ must point to an _errorhooks instance, and that instance MUST be */
	/*  allocated on the stack. If it's statically allocated, then things */
	/*  will irrevocably break. */
	/* Actually, no, it CAN'T be on the stack because of how the runloop */
	/*  will call THIS function... */
retframe _entry( stackpair *stkp, void *v_ )
{
	static token_head
		parenplain = INIT_TOKENHEAD( TOKTYPE_OPPAR, 0,  0,  0, 0, 0 ), /* ( */
		parenup = INIT_TOKENHEAD( TOKTYPE_OPPARUP, 0,  0,  0, 0, 0 ), /* (^ */
		curlup = INIT_TOKENHEAD( TOKTYPE_OPCRLUP, 0,  0,  0, 0, 0 ), /* {^ */
		sqarup = INIT_TOKENHEAD( TOKTYPE_OPSQRUP, 0,  0,  0, 0, 0 ), /* [^ */
		
		plainparen = INIT_TOKENHEAD( TOKTYPE_SYM_PARENCLOSE, 0,  0,  0, 0, 0 ), /* ) */
		upparen = INIT_TOKENHEAD( TOKTYPE_SYM_PREPARCL, 0,  0,  0, 0, 0 ), /* ^) */
		upcurl = INIT_TOKENHEAD( TOKTYPE_SYM_PRECRLCL, 0,  0,  0, 0, 0 ), /* ^} */
		upsqar = INIT_TOKENHEAD( TOKTYPE_SYM_PRESQRCL, 0,  0,  0, 0, 0 ), /* ^] */
		
		comma = INIT_TOKENHEAD( TOKTYPE_SYM_COMMA, 0,  0,  0, 0, 0 ); /* , */
	
#define _entry_DEF_tokhdptr_parr( ... ) \
		LIB4_DEFINE_PASCALARRAY_LITERAL2( tokenheadptr_, token_head*, __VA_ARGS__ )
	static tokhdptr_parr
		nobreaks = _entry_DEF_tokhdptr_parr(  ),
		commabreaks = _entry_DEF_tokhdptr_parr( &comma ),
		
		plainbads = _entry_DEF_tokhdptr_parr( upparen, upcurl, upsqar ),
		parenbads = _entry_DEF_tokhdptr_parr( plainparen, upcurl, upsqar ),
		curlbads = _entry_DEF_tokhdptr_parr( plainparen, upparen, upsqar ),
		sqarbads = _entry_DEF_tokhdptr_parr( plainparen, upparen, upcurl ),
		
		starters = _entry_DEF_tokhdptr_parr( parenplain, parenup, curlup, sqarup );
	
	
	
	
	???
	
	
	
	
	
	
	
	static _specials
		plainspecs = INIT__SPECIALS( tokhead ???,  nobreaks, plainbads, starters,  parenplain, plainparen ),
		parenspecs = INIT__SPECIALS( tokhead ???,  commabreaks, parenbads, starters,  parenup, upparen ),
		curlspecs = INIT__SPECIALS( tokhead ???,  commabreaks, curlbads, starters,  curlup, upcurl ),
		sqarspecs = INIT__SPECIALS( tokhead ???,  commabreaks, sqarbads, starters,  sqarup, upsqar );
	
	
	static retframe_parr
			/* (
				token* bookmark --
					bookmark token* --
					... --
				( token* 0 ) | ( tokengroup* 1 ) | ( tokengroup* tokengroup* token* 2 )
			) */
		onset_ =
			(retframe_parr)
			{
				3, /* Number of retframes  */
				{
						/* ( token* bookmark -- bookmark token* ) */
					(retframe){ &swap2nd, (void*)0 },
						(retframe){ &just_run, (void*)0 },
					(retframe){ &_exit, (void*)0 }
				}
			},
		
			/* ( tokengroup* tokengroup* token* ( 2 ??? ) bookmark -- tokengroup* 2 bookmark ) */
		onerr_ =
			(retframe_parr)
			{
				???, /* Number of retframes  */
				{
					/* The file-static named "hooks" should hold */
					/*  all of the hooks that we need for this. */
					/*  SHOULD. Maybe review it to make certain */
					/*  that it actually does. */
					
					???
				}
			};
	
		/* Remember, the adjusted stuff will get handed directly to */
		/*  enqueue_returns(): it'll be dealt with before there's a */
		/*  chance of the value getting changed again. */
#fefine _entry_RETURN_ONSET( hookname, localname ) \
		onset_.body[ 1 ].data = (void*)&( hookname ); \
		onset_.body[ 2 ].data = v_; \
		return( (retframe){ &enqueue_returns, (void*)&localname } );
	
	retframe
		onset = { &enqueue_returns, (void*)&onset_ },
		
		plain_onerr = { &, (void*)0 },
		paren_onerr = { &, (void*)0 },
		curl_onerr = { &, (void*)0 },
		sqar_onerr = { &, (void*)0 },
		
		??? ;
	
	
		/* bookmark needs to be the name for a uintptr_t, localname will be the name for */
		/*  a retframe_parr that can be used with enqueue_returns(). onset_ptr and */
		/*  onjump_ptr need to be pointers to retframe instances: you should be able to */
		/*  figure out the purpose yourself. Several names will be constructed with */
		/*  prefix at the start, and upper-case text continuing afterwards. */
		/* Note that the user-provided onset and onjump retframes will have to contend */
		/*  with a uintptr_t on top of the data stack: THEY MUST NOT SCREW AROUND WITH */
		/*  THIS (other than to VERY CAREFULLY move stuff underneath it), lest the */
		/*  entire system break, IT MUST BE ON TOP OF THE STACK UPON BOTH onset{} AND */
		/*  onjump{}'s RETURNS. Seriously, here there be dragons. */
		/* Effectively: */
			/* (retframe){ &enqueue_returns, (void*)&localname } : */
			/*  (  -- uintptr_t-bookmark ) -> onset ->  ( uintptr_t-bookmark --  ) */
	LOCALIZE_SETJUMP( plainspecs.bookmark, plaincallable, plainspace,  &onset, &plain_onerr );
	LOCALIZE_SETJUMP( parenspecs.bookmark, parencallable, parenspace,  &onset, &paren_onerr );
	LOCALIZE_SETJUMP( curlspecs.bookmark, curlcallable, curlspace,  &onset, &curl_onerr );
	LOCALIZE_SETJUMP( sqarspecs.bookmark, sqarcallable, sqarspace,  &onset, &sqar_onerr );
	
	
	int scratch;
	STACKCHECK2( stkp, v_,  _entry );
	
	
	if( ( (*_errorhooks)v_ )->th.toktype != ??? )
	{
		???
	}
	if( !_errorhooks_swapdefaults( (_errorhooks*)v_ ) )
	{
		???
	}
	
	
	uintptr_t tok;
	STACKPEEK_UINT( &( stkp->data ), 0, tok,  _entry, scratch );
	token_head *th = (token_head*)tok;
	if( !th )
	{
		???
	}
	
	switch( th->toktype )
	{
		case TOKTYPE_OPPAR: /* ( */
			_entry_RETURN_ONSET( plainspecs, plaincallable );
			
		case TOKTYPE_OPPARUP: /* (^ */
			_entry_RETURN_ONSET( parenspecs, parencallable );
		case TOKTYPE_OPCRLUP: /* {^ */
			_entry_RETURN_ONSET( curlspecs, curlcallable );
		case TOKTYPE_OPSQRUP: /* [^ */
			_entry_RETURN_ONSET( sqarspecs, sqarcallable );
			
			
		default:
			???
	}
}






































#define VALUE_subordinateinfo \
	(divertthread_info){  ???, &escapeinfo  }
static uintptr_t callerinfo_typeid;
static divertthread_callerinfo escapeinfo = { (uintptr_t)&callerinfo_typeid, ??? };
static divertthread_info subordinateinfo = VALUE_subordinateinfo;

typedef struct specials
{
	token_head th;
	
	tokhdptr_parr *breaks, *bads, *starts;
	token_head *start, *end;
	
	divertthread_info *jumpinfo;
	
} specials;
#define INIT__SPECIALS( tokhead,  brkparr, badparr, strtparr,  strtthead, endthead ) \
	(_specials){ (tokhead),  &(brkparr), &(badparr), &(strtparr),  &(strtthead), &(endthead),  0 }

retframe exit( stkp, v_ )
{
	int scratch;
	
	uintptr_t tok;
		/* This is in the way, move it. */
	STACKPOP_UINT( &( stkp->data ), tok,  entry, scratch );
	
		/* First things first, restore the divertthread info! */
	int peek_divertthread_callerinfo( stackframe *stk,  size_t off,  divertthread_callerinfo *val, uintptr_t *user_typeid );
	if( user_typeid != ??? )
	{
		/* Massive error! Not recoverable! */
	}
	int pop_divertthread_callerinfo( stackframe *stk,  divertthread_callerinfo *val );
	int pop_divertthread_info( stackframe *stk,  divertthread_info *val );
	
		/* And now move the "token" back onto the stack. */
	STACKPUSH_UINT( &( stkp->data ), tok,  entry, scratch );
	
	
	if( ( (token_head*)tok )->toktype != ( (specials*)v_ )-> ??? ->toktype )
	{
		/* Error: bracket mismatch! */
	}
	
	returnframe;
}
	retframe accumulate_argrecep( stkp, v_ )
	{
		???
		
		uintptr_t tmp;
		peek( 0, tmp );
		switch( ( (token_head*)tmp )->toktype )
		{
			case comma:
				return( (retframe){ &queue_argrecep, v_ } );
			case :
			case :
			case :
			case :
				returnframe;
			default:
				break;
		}
		
		push_arg();
		
		return( (retframe){ &accumulate_argrecep, v_ } );
	}
	retframe queue_argrecep( stkp, v_ )
	{
		???
		
		return( (retframe){ &accumulate_argrecep, v_ } );
	}
		/* ( token* -- ( token* 0 ) | ( tokengroup* 1 ) | ( tokengroup* 2 ) ) */
reframe entry( stkp, v_ )
{
	static token_head
		parenplain = INIT_TOKENHEAD( TOKTYPE_OPPAR, 0,  0,  0, 0, 0 ), /* ( */
		parenup = INIT_TOKENHEAD( TOKTYPE_OPPARUP, 0,  0,  0, 0, 0 ), /* (^ */
		curlup = INIT_TOKENHEAD( TOKTYPE_OPCRLUP, 0,  0,  0, 0, 0 ), /* {^ */
		sqarup = INIT_TOKENHEAD( TOKTYPE_OPSQRUP, 0,  0,  0, 0, 0 ), /* [^ */
		
		plainparen = INIT_TOKENHEAD( TOKTYPE_SYM_PARENCLOSE, 0,  0,  0, 0, 0 ), /* ) */
		upparen = INIT_TOKENHEAD( TOKTYPE_SYM_PREPARCL, 0,  0,  0, 0, 0 ), /* ^) */
		upcurl = INIT_TOKENHEAD( TOKTYPE_SYM_PRECRLCL, 0,  0,  0, 0, 0 ), /* ^} */
		upsqar = INIT_TOKENHEAD( TOKTYPE_SYM_PRESQRCL, 0,  0,  0, 0, 0 ), /* ^] */
		
		comma = INIT_TOKENHEAD( TOKTYPE_SYM_COMMA, 0,  0,  0, 0, 0 ); /* , */
	
#define entry_DEF_tokhdptr_parr( ... ) \
		LIB4_DEFINE_PASCALARRAY_LITERAL2( tokenheadptr_, token_head*, __VA_ARGS__ )
	static tokhdptr_parr
		nobreaks = entry_DEF_tokhdptr_parr(  ),
		commabreaks = entry_DEF_tokhdptr_parr( &comma ),
		
		plainbads = entry_DEF_tokhdptr_parr( upparen, upcurl, upsqar ),
		parenbads = entry_DEF_tokhdptr_parr( plainparen, upcurl, upsqar ),
		curlbads = entry_DEF_tokhdptr_parr( plainparen, upparen, upsqar ),
		sqarbads = entry_DEF_tokhdptr_parr( plainparen, upparen, upcurl ),
		
		starters = entry_DEF_tokhdptr_parr( parenplain, parenup, curlup, sqarup );
	
	static specials
		plainspecs = INIT__SPECIALS( tokhead ???,  nobreaks, plainbads, starters,  parenplain, plainparen ),
		parenspecs = INIT__SPECIALS( tokhead ???,  commabreaks, parenbads, starters,  parenup, upparen ),
		curlspecs = INIT__SPECIALS( tokhead ???,  commabreaks, curlbads, starters,  curlup, upcurl ),
		sqarspecs = INIT__SPECIALS( tokhead ???,  commabreaks, sqarbads, starters,  sqarup, upsqar );
	
	
	
	
	???
	
	
	static retframe_parr
		plainscript =
			(retframe_parr)
			{
				??? , /* Number of retframes  */
				{
					???
					
						/* v_ must be a pointer to a divertthread_info{}. */
					(retframe){ &divertthread, (void*)& },
					
					???
				}
			},
		parenscript =
			(retframe_parr)
			{
				??? , /* Number of retframes  */
				{
					???
				}
			}
		curlscript =
			(retframe_parr)
			{
				??? , /* Number of retframes  */
				{
					???
				}
			}
		sqarscripts =
			(retframe_parr)
			{
				??? , /* Number of retframes  */
				{
					???
				}
			};
	
	???
	
	
	???
	
	
	int scratch;
	
	retframe ret;
	
	uintptr_t tok;
	STACKPOP_UINT( &( stkp->data ), tok,  entry, scratch );
	
		/* Save the old divertthread info- we'll be needing it if this was nested. */
	int push_divertthread_info( stackframe *stk, divertthread_info val );
		/* Yes, this MUST come last, because it'll ensure that *_callerinfo type id */
		/*  is on TOP of the stack. */
	int push_divertthread_callerinfo( stackframe *stk, divertthread_callerinfo val );
	
		/* Restored! And it's on top of the stuff that we won't need till exit! */
	STACKPUSH_UINT( &( stkp->data ), tok,  entry, scratch );
	
	
		/* Reset the divertthread_info to a nice, safe default. */
	subordinateinfo = VALUE_subordinateinfo;
		subordinateinfo.setfunc = ??? ;
		subordinateinfo.jumpfunc = ??? ;
	
	
	scratch = simplify_toktype( (token_head*)tok,  &tok );
	if( !scratch )
	{
		???
	}
	switch( tok )
	{
		case TOKTYPE_OPPAR:
			ret = (retframe){ &enqueue_returns, (void*)&plainscript };
			break;
		case TOKTYPE_OPPARUP:
			ret = (retframe){ &enqueue_returns, (void*)&parenscript };
			break;
		case TOKTYPE_OPCRLUP:
			ret = (retframe){ &enqueue_returns, (void*)&curlscript };
			break;
		case TOKTYPE_OPSQRUP:
			ret = (retframe){ &enqueue_returns, (void*)&sqarscripts };
			break;
		default:
			/* Throw error: this should never have happened. */
	}
	
	return( ret );
}
uintptr_t callerinfo_typeid = &callerinfo_typeid;
